{
    "Normal1": {
        "prefix": "cppmain",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "void __speed_up() {",
            "    ios::sync_with_stdio(false);",
            "    cin.tie(0);",
            "}",
            "int main() {",
            "    __speed_up();",
            "\t$0",
            "\treturn 0;",
            "}"
        ],
        "description": "cpp syntax"
    },
    "Normal2": {
        "prefix": "cpmain",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "#define int long long",
            "#define size(v) (int)v.size()",
            "#define __startt       \\",
            "    int __testcase;    \\",
            "    cin >> __testcase; \\",
            "    while (__testcase--)",
            "#define endl \"\\n\"",
            "#define print(v)                       \\",
            "    for (auto i : v) cout << i << ' '; \\",
            "    cout << endl",
            "#define all(v) v.begin(), v.end()",
            "void __speed_up() {",
            "    ios::sync_with_stdio(false);",
            "    cin.tie(0);",
            "}",
            "void __solve() {",
            "    ${0:int n;\n    cin >> n;\n    vector<int> v(n);\n    for (auto &i : v) cin >> i;}",
            "}",
            "signed main() {",
            "    __speed_up();",
            "    __startt __solve();",
            "    return 0;",
            "}"
        ],
        "description": "cp syntax"
    },
    "Normal3": {
        "prefix": "cpwithbinSieve",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "#define int long long",
            "#define __startt       \\",
            "    int __testcase;    \\",
            "    cin >> __testcase; \\",
            "    while (__testcase--)",
            "#define endl '\\n'",
            "#define nC2(x) (x <= 1 ? 0 : ((x * (x - 1)) / 2))",
            "#define print(v)                       \\",
            "    for (auto i : v) cout << i << ' '; \\",
            "    cout << endl",
            "#define inpt(v) \\",
            "    for (auto &i : v) cin >> i",
            "#define all(v) v.begin(), v.end()",
            "void __speed_up() {",
            "    ios::sync_with_stdio(false);",
            "    cin.tie(0);",
            "}",
            "const int MOD = 1e9 + 7;",
            "int binExp(int a, int b) {",
            "    int res = 1;",
            "    while (b > 0) {",
            "        if (b & 1) res = (res * 1LL * a) % MOD;",
            "        a = (a * 1LL * a) % MOD;",
            "        b >>= 1;",
            "    }",
            "    return res;",
            "}",
            "vector<int> firstDivisors;",
            "void computeFirstDivisors(int N) {",
            "    firstDivisors = vector<int>(N + 1, -1);",
            "    for (int i = 2; i <= N; i++) {",
            "        if (firstDivisors[i] == -1) {",
            "            firstDivisors[i] = i;",
            "            for (int j = i * i; j <= N; j += i) {",
            "                if (firstDivisors[j] == -1) firstDivisors[j] = i;",
            "            }",
            "        }",
            "    }",
            "}",
            "vector<int> removeDuplicates(vector<int> v) {",
            "    set<int> s;",
            "    for (auto &i : v) s.insert(i);",
            "    vector<int> ans;",
            "    for (auto &i : s) ans.push_back(i);",
            "    return ans;",
            "}",
            "vector<int> findFactors(int k) {",
            "    set<int> f;",
            "    while (k > 1) {",
            "        f.insert(firstDivisors[k]);",
            "        k /= firstDivisors[k];",
            "    }",
            "    vector<int> ans;",
            "    for (auto &i : f) ans.push_back(i);",
            "    return ans;",
            "}",
            "int add(int a, int b) { return (a + 0LL + b) % MOD; }",
            "int sub(int a, int b) { return (a - b + MOD) % MOD; }",
            "int mul(int a, int b) { return (a * 1LL * b) % MOD; }",
            "void __solve() {",
            "    ${0:int n;\n    cin >> n;\n    vector<int> v(n);\n    for (auto &i : v) cin >> i;}",
            "}",
            "signed main() {",
            "    __speed_up();",
            "    __startt __solve();",
            "    return 0;",
            "}"
        ],
        "description": "Template With BinExp and Sieve"
    },
    "binExp": {
        "prefix": "binExp",
        "body": [
            "int binExp(int a,int b,int mod = 1e9 + 7){",
            "\ta %= mod;",
            "\tint res = 1;",
            "\twhile(b){",
            "\t\tif(b&1) res = (res * 1LL * a) % mod;",
            "\t\ta = (a * 1LL * a) % mod;",
            "\t\tb >>= 1;",
            "\t}",
            "\treturn res;",
            "}"
        ],
        "description": "Template for Binary Exponentiation"
    },
    "modularArithmetic": {
        "prefix": "modularArithmetic",
        "body": [
            "const int MOD = 1e9 + 7;",
            "int binExp(int a, int b) {",
            "\tint res = 1;",
            "\twhile (b > 0) {",
            "\t\tif (b & 1) res = (res * 1LL * a) % MOD;",
            "\t\ta = (a * 1LL * a) % MOD;",
            "\t\tb >>= 1;",
            "\t}",
            "\treturn res;",
            "}",
            "int add(int a, int b) { return (a + 0LL + b) % MOD; }",
            "int sub(int a, int b) { return (a - b + MOD) % MOD; }",
            "int mul(int a, int b) { return (a * 1LL * b) % MOD; }",
            "int divi(int a, int b) { return mul(a, binExp(b, MOD - 2)); }"
        ],
        "description": "Template for Modular Arithmetic"
    },
    "computePI": {
        "prefix": "computePI",
        "body": [
            "vector<int> PI(string &s) {",
            "\tvector<int> pi(1, 0);",
            "\tint k = 0;",
            "\tfor (int i = 1; i < s.size(); i++) {",
            "\t\twhile (k > 0 && s[k] != s[i]) k = pi[k - 1];",
            "\t\tif (s[k] == s[i]) k++;",
            "\t\tpi.push_back(k);",
            "\t}",
            "\treturn pi;",
            "}"
        ],
        "description": "Template for Computing PI"
    },
    "computeZFunction": {
        "prefix": "computeZFunction",
        "body": [
            "vector<int> Z(string &s) {",
            "\tint n = s.size();",
            "\tvector<int> z(n);",
            "\tint x = 0, y = 0;",
            "\tfor (int i = 1; i < n; i++) {",
            "\t\tz[i] = max(0, min(z[i - x], y - i + 1));",
            "\t\twhile (i + z[i] < n && s[z[i]] == s[i + z[i]]) {",
            "\t\t\tx = i;",
            "\t\t\ty = i + z[i];",
            "\t\t\tz[i]++;",
            "\t\t}",
            "\t}",
            "\treturn z;",
            "}"
        ],
        "description": "Template for Compute Z function"
    },
    "sparseTable": {
        "prefix": "sparseTableTemplate",
        "body": [
            "class SparseTable {",
            "\tint r, c;",
            "\tvector<int> lg;",
            "\tvector<vector<int>> st;",
            "",
            "\tpublic:",
            "\tSparseTable(vector<int> &v) {",
            "\t\tr = 20;",
            "\t\tc = v.size();",
            "\t\tst = vector<vector<int>>(r + 1, vector<int>(c + 1));",
            "\t\tlg = vector<int>(c + 1);",
            "\t\tfor (int i = 0; i < c; i++) st[0][i] = v[i];",
            "\t\tfor (int i = 1; i <= r; i++) {",
            "\t\t\tfor (int j = 0; (j + (1 << i)) <= c; j++) {",
            "\t\t\t\tst[i][j] = min(st[i - 1][j], st[i - 1][j + (1 << (i - 1))]);",
            "\t\t\t}",
            "\t\t}",
            "\t\tlg[1] = 0;",
            "\t\tfor (int i = 2; i <= c; i++) lg[i] = lg[i / 2] + 1;",
            "\t}",
            "\tint query(int L, int R) {",
            "\t\tint i = lg[R - L + 1];",
            "\t\treturn min(st[i][L], st[i][R - (1 << i) + 1]);",
            "\t}",
            "};"
        ],
        "description": "Template for Sparse Table"
    },
    "segmentTreeTemplate": {
        "prefix": "segmentTreeTemplate",
        "body": [
            "class SegTree {",
            "    vector<int> t, unprop;",
            "    vector<bool> isLazy;",
            "    int n;",
            "    void build(vector<int> &v, int l, int r, int loc) {",
            "        if (l == r) {",
            "            t[loc] = v[l];",
            "            return;",
            "        }",
            "        int m = l + (r - l) / 2;",
            "        build(v, l, m, 2 * loc);",
            "        build(v, m + 1, r, 2 * loc + 1);",
            "        t[loc] = t[2 * loc] + t[2 * loc + 1];",
            "    }",
            "    void pushDown(int loc, int l, int r) {",
            "        if (!isLazy[loc]) return;",
            "        isLazy[loc] = false;",
            "        int m = l + (r - l) / 2;",
            "        giveLaziness(2 * loc, l, m, unprop[loc]);",
            "        giveLaziness(2 * loc + 1, m + 1, r, unprop[loc]);",
            "        unprop[loc] = 0;",
            "    }",
            "    void giveLaziness(int loc, int l, int r, int val) {",
            "        isLazy[loc] = (l != r);",
            "        t[loc] += (r - l + 1) * val;",
            "        if (isLazy[loc]) unprop[loc] += val;",
            "    }",
            "    int query(int loc, int l, int r, int L, int R) {",
            "        if (R < l || r < L) return 0;",
            "        if (L <= l && r <= R) return t[loc];",
            "        int m = l + (r - l) / 2;",
            "        pushDown(loc, l, r);",
            "        return query(2 * loc, l, m, L, R) + query(2 * loc + 1, m + 1, r, L, R);",
            "    }",
            "    void update(int loc, int l, int r, int ind, int val) {",
            "        if (ind < l || r < ind) return;",
            "        if (l == r) {",
            "            t[loc] += val;",
            "            return;",
            "        }",
            "        pushDown(loc, l, r);",
            "        int m = l + (r - l) / 2;",
            "        update(2 * loc, l, m, ind, val);",
            "        update(2 * loc + 1, m + 1, r, ind, val);",
            "        t[loc] = t[2 * loc] + t[2 * loc + 1];",
            "    }",
            "    void rangeUpdate(int loc, int l, int r, int L, int R, int val) {",
            "        if (R < l || r < L) return;",
            "        if (L <= l && r <= R) {",
            "            giveLaziness(loc, l, r, val);",
            "            return;",
            "        }",
            "        pushDown(loc, l, r);",
            "        int m = l + (r - l) / 2;",
            "        rangeUpdate(2 * loc, l, m, L, R, val);",
            "        rangeUpdate(2 * loc + 1, m + 1, r, L, R, val);",
            "    }",
            "",
            "   public:",
            "    SegTree(vector<int> &v) {",
            "        n = v.size();",
            "        t = vector<int>(4 * n);",
            "        unprop = vector<int>(4 * n, 0);",
            "        isLazy = vector<bool>(4 * n, false);",
            "        build(v, 0, n - 1, 1);",
            "    }",
            "    int query(int L, int R) { return query(1, 0, n - 1, L, R); }",
            "    void update(int ind, int val) { update(1, 0, n - 1, ind, val); }",
            "    void rangeUpdate(int L, int R, int val) {",
            "        rangeUpdate(1, 0, n - 1, L, R, val);",
            "    }",
            "};"
        ],
        "description": "Template for Segment Tree"
    },
    "DSU": {
        "prefix": "disjointsetunion",
        "body": [
            "class DSU {",
            "    int n, componentCount;",
            "    vector<int> p, c;",
            "   public:",
            "    DSU(vector<int> v) {",
            "        n = size(v);",
            "        componentCount = n;",
            "        c = vector<int>(n, 0);",
            "        for (int i = 0; i < n; i++) p.push_back(i);",
            "    }",
            "    int find(int x) { return x == p[x] ? x : p[x] = find(p[x]); }",
            "    bool merge(int u, int v) {",
            "        int i = find(u);",
            "        int j = find(v);",
            "        if (i != j) {",
            "            if (c[i] < c[j]) {",
            "                p[i] = j;",
            "                c[j] += c[i];",
            "            } else {",
            "                p[j] = i;",
            "                c[i] += c[j];",
            "            }",
            "            componentCount--;",
            "            return true;",
            "        }",
            "        return false;",
            "    }",
            "    int getComponentCount() {",
            "        return componentCount;",
            "    }",
            "};"
        ],
        "description": "Template Disjoint Set Union"
    }
}